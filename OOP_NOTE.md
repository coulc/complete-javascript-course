
# 面向对象程序设计的4个基本原则
1. 抽象: 忽略或隐藏那些无关紧要的细节,使我们能够从宏观角度审视我们正在实现的事物,而不是纠结于那些对我们的实现并不重要的细节
2. 封装: 在类内部保持属性和方法的私有性,这样它们就不能从类的外部访问,有些方法可以被暴露为公共接口(API)
3. 继承: 将某个类的所有属性和方法都提供给子类使用,从而在类之间形成一种层次关系,这使我们能够重用通用逻辑,并且能够模拟现实世界中的关系。 
4. 多态: 子类可以覆盖从父类继承的方法

# 构造函数创建实例的过程:
1. 创建一个新的对象
2. 将构造函数的作用域赋值给新对象(这this就指向了该对象)
3. 执行构造函数中的代码(为新对象添加实例属性和实例方法)
4. 返回新对象

# prototype 
函数的专属属性
```
function Person() {};
console.log(Person.prototype);  // 存在
```
只有函数才有prototype,它是该函数的'原型函数'.
当new创建实例的时候,这个对象会成为实例的原型

# __proto__
每个通过构造函数创建出来的实例的对象,其本身有个属性__proto__,这个属性会指向该实例对象的构造函数的原型对象.
所有的原型对象的__proto__属性都是指向function Object的原型对象
原型链的尽头是null
最好通过Object.getPrototypeOf() 来获取

# 原型链
当访问一个对象的某个属性时，会先在这个对象本身属性上查找,
如果没有找到，则会通过它的__proto__隐式属性，找到它的构造函数的原型对象，
如果还没有找到就会再在其构造函数的prototype的__proto__中查找，
这样一层一层向上查找就会形成一个链式结构，我们称为原型链.

# 原型对象
JS的每个函数在创建的时候,都会生成一个属性prototype,这个属性指向一个对象,这个对象就是此函数的原型对象.
该原型对象中有一个属性为constructor,指向该函数.
这样原型对象和它的函数之间就产生了联系.
```
// 构造函数
function Preson(name, age) {
this.name = name;
this.age = age;
}

// 所有实例共享的公共方法
Preson.prototype.say = function (word) {
console.log(`${this.name}说：${word}`);
}

const p1 = new Preson('coulc', 18); // 创建一个Person实例对象
p1.hasOwnProperty('say');           // false 说明不是定义在其本身上的
p1.say('hello world');              // 调用公共方法 打印：coulc说：hello world

```

# ES6 class
cless有两种声明方式
```
const Person = class{}  // 类表达式

class Person {} // 类声明
```
类中的实例方法会被添加到.prototype;

- get set 
用于定义对象属性的访问器（accessor）的特殊方法,
允许你在读取或修改属性时执行额外的逻辑，而不是直接操作数据

当一个属性有一个对应的 set 的时候会自动调用该函数,set必须要有一个参数
------------------ get 和 set ------------------
特性	        Getter (get)	        Setter (set)
触发时机	    访问属性时	            赋值属性时
用途	        计算属性、格式化数据	数据校验、触发副作用
返回值	        必须返回一个值	        不返回（接收一个参数）
递归风险	    无	                    如果内部赋值同名属性，会导致无限循环(使用 _ 解决)



_  : 约定俗成的命名方式，表示“内部属性”，但并非强制(ES6 之前没有真正的私有属性),在get中可以避免无限递归问题
#: 真正意义上的私有属性

-------------------- # -------------------- 
特性	    说明
强制私有	外部无法直接访问 #field，包括子类
硬性限制	即使通过 this.#field 拼写错误也会报错
兼容性	    现代浏览器和 Node.js 14+ 支持
动态访问    完全无法动态访问
tips: 动态访问指的是通过 变量名 或 运行时计算的字符串 访问对象的属性，而不是直接写死属性名


# Static Method  静态方法
直接绑定到类本身,而不是类的实例,通过类名直接调用

为什么实例无法访问？ 
    静态方法 是直接绑定到构造函数上的,不在原型链中,所以实例无法访问

this 指向类本身（构造函数）
静态方法无法访问实例属性
```
class Person{
    ... 
    static sayHello(){...}
}

Person.sayHello();
```

call()：调用函数并指定 this 值，传递多个参数。
apply()：调用函数并指定 this 值，传递一个参数数组。
bind()：创建一个新函数，其 this 值被永久绑定到指定的对象，可以提前绑定一些参数。
